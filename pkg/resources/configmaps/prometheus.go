/*
 * Copyright (C) 2020, MinIO, Inc.
 *
 * This code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License, version 3,
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 */

package configmaps

import (
	"fmt"
	"time"

	jwtgo "github.com/dgrijalva/jwt-go"
	miniov1 "github.com/minio/operator/pkg/apis/minio.min.io/v1"
	"gopkg.in/yaml.v2"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	defaultPrometheusJWTExpiry = 100 * 365 * 24 * time.Hour
)

type globalConfig struct {
	ScrapeInterval     time.Duration `yaml:"scrape_interval"`
	EvaluationInterval time.Duration `yaml:"evaluation_interval"`
}

type staticConfig struct {
	Targets []string `yaml:"targets"`
}

type tlsConfig struct {
	CAFile string `yaml:"ca_file"`
}

type scrapeConfig struct {
	JobName       string         `yaml:"job_name"`
	BearerToken   string         `yaml:"bearer_token"`
	MetricsPath   string         `yaml:"metrics_path"`
	Scheme        string         `yaml:"scheme"`
	TLSConfig     tlsConfig      `yaml:"tls_config"`
	StaticConfigs []staticConfig `yaml:"static_configs"`
}

type prometheusConfig struct {
	Global        globalConfig   `yaml:"global"`
	ScrapeConfigs []scrapeConfig `yaml:"scrape_configs"`
}

func genBearerToken(accessKey, secretKey string) string {
	jwt := jwtgo.NewWithClaims(jwtgo.SigningMethodHS512, jwtgo.StandardClaims{
		ExpiresAt: time.Now().UTC().Add(defaultPrometheusJWTExpiry).Unix(),
		Subject:   accessKey,
		Issuer:    "prometheus",
	})

	token, err := jwt.SignedString([]byte(secretKey))
	if err != nil {
		panic(fmt.Sprintf("jwt key generation: %v", err))
	}

	return token
}

// getMinioPodAddrs returns a list of stable minio pod addresses.
func getMinioPodAddrs(t *miniov1.Tenant) []string {
	targets := []string{}
	for _, pool := range t.Spec.Pools {
		poolName := t.PoolStatefulsetName(&pool)
		for i := 0; i < int(pool.Servers); i++ {
			target := fmt.Sprintf("%s-%d.%s.%s.svc.%s:%d", poolName, i, t.MinIOHLServiceName(), t.Namespace, miniov1.GetClusterDomain(), miniov1.MinIOPort)
			targets = append(targets, target)
		}
	}
	return targets
}

func getPrometheusConfig(t *miniov1.Tenant, accessKey, secretKey string) string {
	bearerToken := genBearerToken(accessKey, secretKey)
	minioTargets := getMinioPodAddrs(t)
	minioScheme := "http"
	if t.TLS() {
		minioScheme = "https"
	}

	// populate config
	promConfig := prometheusConfig{
		Global: globalConfig{
			ScrapeInterval:     10 * time.Second,
			EvaluationInterval: 30 * time.Second,
		},
		ScrapeConfigs: []scrapeConfig{
			{
				JobName:     "minio",
				BearerToken: bearerToken,
				MetricsPath: "/minio/prometheus/metrics",
				Scheme:      minioScheme,
				TLSConfig: tlsConfig{
					CAFile: "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
				},
				StaticConfigs: []staticConfig{
					{
						Targets: minioTargets,
					},
				},
			},
		},
	}

	d, err := yaml.Marshal(&promConfig)
	if err != nil {
		panic(fmt.Sprintf("error marshaling to yaml: %v", err))
	}

	configFileContent := fmt.Sprintf(`# This file and config-map is generated by MinIO Operator.
# DO NOT EDIT.

%s`, d)
	return configFileContent
}

// PrometheusConfigMap returns configuration for Prometheus.
func PrometheusConfigMap(t *miniov1.Tenant, accessKey, secretKey string) *corev1.ConfigMap {
	configFileContent := getPrometheusConfig(t, accessKey, secretKey)

	return &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:            t.PrometheusConfigMapName(),
			Namespace:       t.Namespace,
			OwnerReferences: t.OwnerRef(),
		},
		Data: map[string]string{
			"prometheus.yml": configFileContent,
		},
	}
}

// UpdatePrometheusConfigMap checks if the prometheus config map needs update
// and if so returns the updated map. Otherwise it returns nil.
func UpdatePrometheusConfigMap(t *miniov1.Tenant, accessKey, secretKey string, existing *corev1.ConfigMap) *corev1.ConfigMap {
	existingConfigFile := existing.Data["prometheus.yml"]

	configFileContent := getPrometheusConfig(t, accessKey, secretKey)

	// FIXME(aditya): do a better check by validating the prometheus bearer
	// token for minio instead of generating a new one.
	if existingConfigFile != configFileContent {
		return &corev1.ConfigMap{
			ObjectMeta: metav1.ObjectMeta{
				Name:            t.PrometheusConfigMapName(),
				Namespace:       t.Namespace,
				OwnerReferences: t.OwnerRef(),
			},
			Data: map[string]string{
				"prometheus.yml": configFileContent,
			},
		}
	}
	return nil
}
